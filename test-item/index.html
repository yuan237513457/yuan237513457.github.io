<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
</head>
<body>
    <!-- <style>
    *{
        margin: 0;
        padding: 0;
        text-decoration: none;
    }
    .sanjiao{
        width: 0px;
        height: 0px;
        border: 100px solid transparent;
        border-bottom: 100px solid red;
    }
    
    </style>
    <div class="sanjiao"></div> -->

    <!-- <style>
    *{margin: 0px;
      padding: 0px;
       
        }
    .div1{
        width: 200px;
        height: 200px;
        background: #0ff;
       position: relative;
        
    }
    .div2{
        position: absolute;
       width: 100px;
       height: 100px;
       top: 50%;
       left: 50%;
       margin-top: -50px;
       margin-left: -50px;
       background: red;

    }
    .div3{
      position: absolute;
        width: 80px;
        height: 80px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        margin: auto;
        background: pink;
    }
    .div4{
        position: absolute;
       width: 60px;
       height: 60px;
       top: 50%;
       left: 50%;
       
       transform: translate(-50%,-50%);
       -webkit-transform: translate(-50%,-50%);
       -moz-transform: translate(-50%,-50%);
       -ms-transform: translate(-50%,-50%);
       
       background: red;
    }
    </style>
        <div class="div1">
            <div class="div2">
                   
            </div>
            <div class="div3">
 
            </div> 
           <div class="div4">

                </div> 

        </div>
 -->





  <script>
 
// var n = parseInt(window.prompt('input'));

// var mul = 1;
// for(var i = 0; i < n; i++){
//     mul*=2;
// }
// document.write(mul);

// var n = 1;
//  switch(n){
//     case 1:
//         console.log('a');
//         break;
//     case 2:
//         console.log('b');
//         break;
//     case 3:
//         console.log('c');
//         break;
//  }


// var mul = 0;
// for( var i = 0; i < 100; i++){
//     mul += i;
//     console.log(i);
//     if(mul > 100){
//         break;
//     }
// }


// var arr = [1,2,3,4,'abc',undefined];
// for(var i = 0; i < arr.length; i++){
//     console.log(arr[i]);
// }


//  var obj = new Object();


// var obj = {

//     name : "deng",
//     age : 29,
//     sex : undefined,
//     wife : "xiaoliu",
//     father : "xiaowang",
//     son : "xiali"

// }

//  console.log(obj.name);



// var num = "101010";

// var test = parseInt(num,2);
// console.log(test.toString(16));


//  var num = 'i`m a lasagna hog';
//  console.log(num.split('').reverse().join(''));



// var text = (window.foo || (window.foo = 'bar'));
//  console.log(text);

// 输入动物，出现相应的叫声

//    function jiao(dongwu) {

//        switch(dongwu) {

//             case "dog":
//                 document.write("汪汪汪!");
//                 return;
//             case "cat":
//                 document.write("喵喵喵！");
//                 return;
//             case "fish": 
//                 document.write("o~o~o!");
//                 return;
//        }


//    }


 //累加求和

//  function num() {
//      var nul = 0;
//      for(var i = 0; i < arguments.length; i ++){
//          nul += arguments[i];
//      }
//      console.log(nul);
//  }

//  num(1,2,3,4,2,1);



 

// 前面加+号 ，可以转换成 number 类型


//  function myNumber(target) {
//      return +target;
//  }

// var num = myNumber("123");
//  console.log(typeof(num) + ":" + num);



// 输入一个数字，得出反向汉字

// function reverse() {
//     var num = window.prompt("input");
//     var str = "";
//     for(var i = num.length - 1; i >= 0; i --){
//          str += transfer(num[i]);
    
//     }
//         document.write(str);
// }

// function transfer(target) {

//     switch(target){
//         case "1" : 
//             return "一";
//         case "2" : 
//             return "二";
//         case "3" : 
//             return "三";
//     }

// }

//  算阶乘用的 递归

// function jc(n) {

//     if(n == 1) {
//         return 1;
//     }

//     return n * jc(n-1);

// }







// function reverse() {
//     var num = window.prompt("input");
//     var str = "";
//     for(var i = 0; i < num.length; i ++){
//          str += transfer(num[i]);
    
//     }
//         document.write(str);
// }

//      亿  千万  百万  十万  万  千  百  十  transfer() 元

// function danwei(a,b,c,d,e,f,g,h,t) {

//     if(num.length = 9){
        
//     }

// }



// function transfer(target) {

//     switch(target){
//         case "1" : 
//             return "壹";
//         case "2" : 
//             return "贰";
//         case "3" : 
//             return "叁";
//         case "4" : 
//             return "肆";
//         case "5" : 
//             return "伍";
//         case "6" : 
//             return "陆";
//         case "7" : 
//             return "柒";
//         case "8" : 
//             return "捌";
//         case "9" : 
//             return "玖";
//     }

// }


//  递归     典型的例子， 阶乘 ，斐波那契数列;
            // 规律   底层的递归完，才执行 先递归的
//         // 1.找规律
//         // 2.找出口


// n的阶乘

// function mul(n){

//     // var num = 1;
//     // for(var i = 1; i <= n; i ==) {
//     //     num *=i;
//     // }

//    
//     // n! = n * (n-1)! 

//         if( n == 1 || n == 0){
//             return 1;
//         }   //出口 在n=1的时候出口;

//         return n * mul(n-1);

// }

// nul(5);

// mul(5) ==> 5 * mul(4);
// mul(4) ==> 5 * mul(3);
// mul(3) ==> 5 * mul(2);
// mul(2) ==> 5 * mul(1);

//    斐波那契数列 规律  fb(n) == fb(n - 1) + fb(n - 2);

// function fb(n) {

//     if( n == 1 || n == 2) {    //出口 
//         return 1;
//     }
//     return fb(n - 1) + fb(n - 2); //规律
// }

// fb(5) ==> fb(4) + fb(3);
// fb(4) ==> fb(3) + fb(2);  fb(3) ==> fb(2) + fb(1);
// fb(3) ==> fb(2) + fb(1); 




        // 预编译


        // JS  单线程  解释性预约  解释一行执行一行

        // 1. 语法分析 （先扫描一遍看 有没有错误）
        // 2. 语法编译 （ 预编译） 预编译发生在函数执行的前一刻
        // 3. 解释一行执行一行


    //  变量没声明 使用会报错 


    //  函数声明整体提升
    //  变量 声明提升


        // imply global  
        // 暗示全局变量 ：即任何变量，如果变量未经声明就赋值，此变量就为全局对象所有。
        // 一切声明的全局变量，都是window全局变量。
        // window 就是全局


        // 1.创建AO对象  Activation Object(执行期上下文);

        // 2.找形参和变量声明，将变量和形参名作为AO属性名，值为undefined

        // 3.将实参值和形参统一

        // 4.在函数体里面找函数声明，值赋予函数体



        // function bar() {
        //     return foo;
        //     foo = 10;
        //     function foo() {}
        //     var foo = 11;
        // }

        
        //  console.log(bar());


           

    // console.log(bar());
    //     function bar() {
    //         foo = 10;
    //         function foo() {}
    //     var foo = 11;
    //     return foo;
    //     }

    

        // function a() {

        //     var num = 100;

        //     function b() {
        //         num ++;
        //         console.log(num);
        //     }
        //     return b;

        // }
        // var demo = a();
        // demo();
        // demo();


//    闭包实现 累加
//     function add() {
//         var count = 0;
//         function demo() {
//             count ++;
//             console.log(count);
//         }
//         return demo;
//     }
//          var counter = add();
//          counter();
//          counter();
//          counter();
//          counter();

    // 立即执行函数

    // (function (){
    //     var a = 123;
    //     var b = 234;
    //     console.log(a + b);
    // }())

        //  可以有参数
        // (function (a,b,c){
        //     console.log(a + b + c*2);
        // }(1,2,3))

        // 带返回值

        // var num = (function (a,b,c){
        //     var d = a + b + c * 2 -2;
        //     return d;
        // }(1,2,3))


        // 函数声明                       函数表达式
        // function test(){}            var test = function (){}();
                                        // 只有表达式才能被执行符号执行



        // 解决闭包循环方法，立即执行函数


            // function test() {
            //     var arr = [];
            //     for(var i = 0; i < 10; i ++) {

            //        ( function (j){   //形参
            //         arr[j] = function () {
            //             document.write(j + " ");
            //         }
            //        }(i));  //实参

            // }
            // return arr;

            // }
            
            // var myArr = test();
            // for(var j = 0; j < 10; j++) {
            //     myArr[j]();
            // }



                // 当a执行完a的AO被销毁，b获取到了a的AO所以b输出123 不会报错；闭包的效果
                // 两个函数互相嵌套，把里面的函数保存到了外部，这样的一个情况，必然会生成一个闭包，
                // 里面的函数在外面执行的时候必然能获取到外面函数的属性。

                // function a() {

                //     function b() {
                //         var bbb = 234;
                //         document.write(aaa);
                //     }

                //     var aaa = 123;
                //     return b;

                // }

                // var glob = 100;
                // var demo = a();
                // demo();


            // eatFood 跟 pushFood 都在同一个test里面，公用一个test得AO，所以修改了，他们两个
            // 同时改变。

                //   function test() {
                //       var food = "apple";
                //       var obj = {
                //           eatFood : function () {
                //               if(food != "") {
                //                   console.log("I an earing " + food);
                //                   food = "";
                //               }else{
                //                   console.log("There is nothing! empty!");
                //               }
                //           },
                //           pushFood : function (myFood){
                //               food = myFood;
                //           }
                //       }
                //       return obj;
                //   }  

                //   var person = test();

                //   person.eatFood();
                //   person.eatFood();
                //   person.pushFood("banana");
                //   person.eatFood();

 </script>



   <!-- <ul>
       <li>a</li>
       <li>a</li>
       <li>a</li>
       <li>a</li>
   </ul>

    使用原生JS，addEventListener,给每个li元素绑定一个click事件，
    并输出他们的顺序 -->


    <!-- <style>
    *{
        margin: 0;
        padding:0;
    }
    ul{
        list-style: none;
    }
    li:nth-of-type(2n){
            background: red;
        }
    li:nth-of-type(2n+1){
        background: yellow;
    }
    li{
       text-align: center;
    
    }
    </style>


    <ul>
        <li>a</li>
        <li>a</li>
        <li>a</li>
        <li>a</li>
    </ul>

    // 利用 立即执行函数，结局闭包输出不正确问题

    <script type="text/javascript">
    
    function test() {

    var liList = document.getElementsByTagName('li');

    for(var i = 0; i < liList.length; i++){
        
         (function (j) {
            liList[j].onclick = function () {
                console.log(j);
            }

        }(i))

    }


  }


test(); -->

    <script>
    
    //     a = 100;
    //     function demo(e) {
    //         function e() {}
    //         arguments[0] = 2;
    //         console.log(e); //  2
    //         if(a) {
    //             var b = 123;
    //             function c() {
    //                 //猪都能做出来
    //             }
    //         }
    //         var c;
    //         a = 10;
    //         var a;
    //        console.log(b); //undefinder
    //         f = 123;        // 函数里没有定义的表达式，是全局变量里GO
    //        console.log(c); // function
    //        console.log(a);  // 10

    //     }
    
    //     var a;
    //     demo(1); 
    //    console.log(a); // 100
    //    console.log(f);  //123
    
    
  //用 charCodeAt 方法计算一个字符串的字符长度

        // function retByteslen(target) {
        //     var count = 0;
        //     for(var i = 0; i < target.length; i++) {
        //         if(target.charCodeAt(i) <= 255) {
        //             count ++;
        //         }else if( target.charCodeAt(i) > 255) {
        //             count += 2;
        //         }
        //     }

        //     console.log(count);
        // }

    
        // // 精简 优化版

        
        // function retByteslen(target) {
        //     var count,
        //         len;
        //         count = len = target.length;
        //     for(var i = 0; i < len; i++) {
        //         if(target.charCodeAt(i) > 255) {
        //             count ++;
        //         }
        //     }
           
        //     console.log(count);
        // }


            // 微店笔试
            // 写出下来程序的执行结果   ,逗号操作符 会把后面计算结果返回出去
        //   1.  
    // var f=(
    //     function f() {
    //         return "1";
    //     },
    //     function g() {
    //         return 2;
    //     }
    // )();
    //     typeof f; //number

        // 2.
        // var x = 1;
        // if(function f() {}) { //在括号里就会 函数声明就会变成表达式，变成表达式f 就消失了
        //     x += typeof f;    // 未经声明就使用的变量，放到typeof里不会报错 返回undefined,是字符串类型
        // }
        // x;


            // 构造函数 必须要 加 new，加了new函数内就会默认添加一个var this = {}
            // 在结尾处还有一个 隐世的 return


            //  包装类
            // 在原始值调用属性的时候，自己不能用，他会隐世发生一个过程 new 一个 Number
            
            // var num = 4;
            // num.len = 3;
            // // new Number(4).len = 3;   delete
            // console.log(num.len);

            // var str = "abcd";
            // str.length = 2;
            // // new String("abcd").length = 2; delete
            // console.log(str);




            // var str = "abc";
            // str += 1;
            // if(test.length == 6){
            //     test.sign = "typeof的返回结果可能为String";
                //  包装类 问题 ；test是原始值 没有方法是系统自动生成一个
                //  new  String(test).sign = ；；；；   delete
            // }
                //  new String(test).sign 下面调用的是这个新的，所有是undefined
            // console.log(test.sign); // undefined





        // function Person(name,age,sex) {
        //     var a = 0;
        //     this.name = name;
        //     this.age = age;
        //     this.sex = sex;
        //     function sss() {
        //         a ++ ;
        //         console.log(a);
        //     }
        //     this.say = sss;
        // }

        // var oPerson = new Person();
        // oPerson.say(); //1
        // oPerson.say(); //2
        // var oPerson1 = new Person();
        // oPerson1.say(); //1



            // var x = 1; y = z = 0;
            // function add(n) {
            //     return n = n + 1;

            // }

            // y = add(x);

            // function add(n) {
                
            //     return n = n + 3;
            // }
            
            // z = add(x);

                //  主要查看执行先后顺序， 两个函数一样，上面的先提升上去，然后第二个在提升上去，把第一个覆盖住
                // 所以 只会执行下面这个函数



                // 1.当前字符为unicode > 255,那么该字符字节长度为2；
                // 1. <=255为1；
                
                // var str = "abcd李白";

                // function bytesLength(str) {
                //     // var count = str.length;
                //     // for(var i = 0; i < str.length; i++) {
                //     //     if(str.charCodeAt(i) > 255) {
                //     //          count ++;
                //     //     }
                //     // }
                   
                //         var count = 0;
                //         for(var i = 0; i < str.length; i++) {
                //             if(str.charCodeAt(i) > 255) {
                //                 count += 2;
                //             }else{
                //                 count ++;
                //             }
                           
                //         } 
                //         return count;

                // }



                        // 原型
                        //  person.prototype -- 原型
                        //  person.prototype = {} 是祖先


                    // function Person() {

                    // }
                    
                    // Car.prototype = {} //改变原型上的内容，就是改变 Car 的祖先遗传

                    // Car.prototype = {
                    //     constructor : Car //就可以改变他的 原指向 constructor
                    // }
                    // function Car() {

                    // }
                    // var car = new Car();


                    
                        // Person.prototype.name = "sunny";
                        // function Person() {}
                        // var person = new Person();
                        
                        // Person.prototype = {
                        //     name : "cherry"
                        // }
                        
                            // 可正常计算的范围  小数点前 16位， 后16位。


                // call 需要把实参按照形参的个数传进去
                // apply 需要传一个arguments 数组

                            // 改变this指向，只有传参列表不同




                            // function foo() {bar.apply(null,arguments)}
                            // function bar(x) {console.log(arguments)}
                            // foo(1,2,3,4,5)





                            // 函数代表功能付用、
                
                    // Father.prototype.lastName = "Deng";
                    // function Father() {

                    // }

                    // function Son() {

                    // }

                    // 如果想让son继承Father的属性，可以使用下面这个 inherit 

            //     function inherit(Target,Origin) {

            //         Target.prototype = Origin.prototype;
            //     }

            //    inherit(Son,Father);

            //     var son = new Son;
 
                // 一定是先继承inherit(Son,Father) 后 var son = new Son;使用


                // 圣杯模式，又可以改自己的又可以继承别人的

                //                 Father.prototype

                //                                     function F() {}
                //                                     F.prototype = Father.prototype;

                //                                     Son.prototype = new F();

                // Fathers                                       Son


                // 圣杯模式       ****牢记

            //         function inherit(Target,Origin) {
            //             function F() {};
            //             F.prototype = Origin.prototype;
            //             Target.prototype = new F();
            //             Target.prototype.constuctor = Target;
            //             Target.prototype.uber = Origin.prototype;
            //         }

            //         Father.prototype.lastName = "deng";
            //         function Father() {}
            //         function Son() {}

            //         inherit(Son,Father);
            //         var son = new Son;
            //         var father = new Father;

                
            //         // 精简方法   每天一遍

            // var inherit = (function () {
            //     var F = function() {};
            //     return function(Target,Origin) {
            //         F.prototype = Origin.prototype;
            //         Target.prototype = new F();
            //         Target.prototype.constuctor = Target;
            //         Target.prototype.uber = Origin.prototype;
            //     }
            // }());


            


            
                // return this;  连续调用
                

                // 遍历 枚举 对象用的 ，for in 循环 ，因为不知道 对象的 length 所有用 for in
                // 如果是手动设置的原型上的 值 都可以打印，系统自带的不能打印
                // 遍历属性想获取对象 里面的值  要写成 方括号形式  obj[prop] ;

                // 如果不想获取原型上的属性 要使用 hasOwnProperty方法

                // in 操作符， 是能不能在 对象上 调用这个属性 原型上的也算。

            //    var obj = {
            //        name : "13",
            //        age : 123,
            //        sex : "male",
            //        height : 169,
            //        weight : 32,
            //        __proto__ : {
            //            lastName : "deng"
            //        }
            //    }

            //    for (var prop in obj) {
            //        if(obj.hasOwnProperty(prop)){
            //             console.log(obj[prop]);
            //        }
                  
            //    }
                


                // instanceof操作符
                // A对象 是不是 B构造函数构造出来的
                // 看A对象的原型链上 有没有 B的原型
                // A instanceof B

        //  var person = new Person();
        //         person instanceof Person 
            

            


                // 区别 数组 和  对象 的方法  []  {}

                // var arr = [];
                // var obj = {};

                // // 第一种  用 constructor

                // [].constructor //function Array() { [native code]}
                
                // // 这里要用 obj 代替 {} 因为系统会默认 {} 为 function () {} 
                // obj.constructor // function Object() { [native code]}

                // // 第二种  用 instanceof
                
                // [] instanceof Array //true

                // obj instanceof Array //false

                // // 第三种   用  call toString    (各种构造函数都重写了 toString方法)

                // Object.prototype.toString.call([]); //array
                // Object.prototype.toString.call(123);    // number
                // Object.prototype.toString.call({}); // object



                //  typeof 返回值   空值传到typeof里 返回 undefined
                
            // number  srting  boolean  object   undefined  function

                
    
    
                // var foo = "123";
                // function print() {
                //     var foo = "456";
                //     this.foo = "789";
                //     console.log(foo);
                // }
                // print();


                // function print() {
                //     console.log(foo);
                //     var foo = 2;
                //     console.log(foo);
                //     console.log("hello");
                // }
                
                // print();


            // var name = "222";
            // var a = {
            //     name : "111",
            //     say : function () {
            //         console.log(this.name);
            //     }
            // }
            // var fun = a.say;
            // fun()  //222
            // a.say()  //111
            // var b = {
            //     name : "333",
            //     say : function (fun) {
            //         fun();
            //     }
            // }
            // b.say(a.say);  //222
            // b.say = a.say; 
            // b.say(); //333




                // var a = 5;
                // function test () {
                //         // var this = {
                //             // new一个函数的时候 内部会创建一个这样的this
                //             //this里 没有a所以打印 undefined
                //         //     __proto__ : test.prototype
                //         // }

                //     a = 0;
                //     alert(a);
                //     alert(this.a);
                //     var a;
                //     alert(a);
                // }

                // test();  //0   5    0
                // new test(); // 0   undefined   0



                    // function print() {
                    //     var marty = {
                    //         name : "marty",
                    //         printName : function () {
                    //             console.log(this.name);
                    //         }
                    //     }

                    //     var test1 = {name : "test1"};
                    //     var test2 = {name : "test2"};
                    //     var test3 = {name : "test3"};
                    //     test3.printName = marty.printName;
                    //     var printName2 = marty.printName.bind({name : 123});
                    //     marty.printName.call(test1);
                    //     marty.printName.apply(test2);
                    //     printName2();
                    //     test3.printName();
                    // }

                    // print();



                        // var bar = { 
                        //     a : "002"       //a = "a"
                        // };
                        // function print() {
                        //     bar.a = "a";
                        //     Object.prototype.b = "b";

                        //     return function inner() {
                        //         console.log(bar.a);
                        //         console.log(bar.b);
                        //     }
                        // }

                        // print()();  //第一个括号返回的是 函数 function inner(){}
                        //             //第二个括号是函数执行



                        // 普通克隆模式
                //     var obj = {
                //         name : "abc",
                //         age : 123,
                //         sex : "female",
                //         card : ["visa","unionpay"]
                //     }
                //     var obj1 = {};
                //   function kelong(origin,target) {
                //       var target = target || {}; //如果不传参就自己做一个{}，如果穿了就用target
                //      for(var prop in origin) {
                //       target[prop] = origin[prop]                    
                //      }
                //         return target;
                //     }
                //   kelong(obj,obj1);




                    // 深层克隆模式


                    // var obj = {
                    //     name : "abc",
                    //     age : 123,
                    //     sex : "female",
                    //     card : ["visa","unionpay"],
                    //     wife : {
                    //         nun : "334",
                    //         qwe : {
                    //             er : "df",
                    //             trer : "bdfd",
                    //         }
                    //     }
                    // }

                    // var obj1 = {};
                    // 判断有没有给复制的对象
                    // 遍历对象 for(var prop in obj)
                    // 1.判断是不是原始值 typeof() boject
                    // 2.判断是数组还是对象 instanceof constructor toString
                    // 3.建立了相应的数组或对象
                    // 递归


            
            //     function deepClone(origin,target) {
            //         var target = target || {},
            //             toStr = Object.prototype.toString,
            //             arrStr = "[object Array]";
            //         for(var prop in origin) {
            //             if(origin.hasOwnProperty(prop)) {
            //                 if(origin[prop] !== "null" && typeof(origin[prop]) == 'object') {
            //                    target[prop] = toStr.call(origin[prop]) == arrStr ? [] : {};
            //                     deepClone(origin[prop],target[prop]);
            //                 }else{
            //                     target[prop] = origin[prop];
            //                 }
            //             }
            //         }
            //         return target;
            //     }
            // deepClone();



            // 数组   
            // 封装 type方法

                // 两种构造方法
                // var arr = [];   //数组自变量 ****优先

                // var arr = new Array(); 
                // 区别：new Array() 里面传参 是表示数组的长度; [] 里传参是 数组内的内容;


               
                // es3.0 标准   es5.0 加了几个新方法   es6.0 最新的 
                // ECMAScript    DOM   BOM

                
                // 改变数组的几种方法
                // push, pop, shift, unshift, sort, reverse
                
                // splice

                //不改变原数组

                // concar, join --> split, toString, slice
                //拼接    



                //push( 在数组的最后一位添加数据 )
                // unshift() 在数组的前面一位添加数据
                //pop() 把数组的最后一位剪切出来 ，传参没有用
            

                // 原理
                // var arr = [1,2,3];

                // Array.prototype.push = function () {
                //     for(var i = 0; i < arguments.length; i++) {
                //         this[this.length] = arguments[i];
                //     }
                //     return this.length;
                // }


                // 升序 降序

                // var arr = [10,2,10,13,4,8,9];
                // arr.sort(function (a,b) {
                //     //return a - b; 升序
                //     //return b - a; 降序 
                // })


                // 给一个有序的数组，乱序

                // var arr = [1,2,3,4,5,6,7];

                // arr.sort(function() {
                //     return Math.random() - 0.5;
                // })

                // 判断字节长度

                // function retBytes(str) {
                    
                //     var num = str.length;
                //     for(var i = 0; i < str.length; i ++) {
                //         if(str.charCodeAt(i) > 255) {
                //             num ++;
                //         }
                //     }
                //     return num
                // }


                //    类数组 组成部分 

                   // 属性要为索引 （数字） 属性，必须有length属性，最好加上push , splice
                //  好处





                // var obj = {
                //     "2" : 'b',
                //     "3" : 'c',
                //     "length" : 2,
                //     "push" : Array.prototype.push
                // }

                // obj.push('a');
                // obj.push('d');


                // // push 内部原理 是根据 length改变的

                // Array.prototype.push = function (target) {
                //     obj[obj.length] = target;
                //     obj.length ++;
                // }


                    // 判断类型

                    // function type(target) {
                    //     //1.分两类 原始值 引用自
                    //     //2.区分 引用自
                    //     var template = {
                    //         "[object Array]" : "array",
                    //         "[object Object]" : "object",
                    //         "[object Number]" : "number - object",
                    //         "[object Boolean" : "boolean - object",
                    //         "[object String]" : "string - object"
                    //     }
                    //     if(target === null) {
                    //         return "null";
                    //     }else if(typeof(target) == "object") {
                    //         var str = Object.prototype.toString.call(target);
                    //         return template[str];
                    //     }else{
                    //         return typeof(target);
                    //     }  
                    // }


                        //数组去重 加升序 排序

            // var arr = [1,1,1,1,2,2,2,1,1,1,2,1,1,5,4,45,45,5,5,45,1];
                        

            // Array.prototype.quchong = function () {
            //     var obj = {},
            //         arr = [],
            //         len = this.length;
            //     for(var i = 0; i < len; i ++) {
            //         if(!obj[this[i]]){  //如果取到值没操作，没有取到值（为undefined）是为他赋值；
            //             obj[this[i]] = 'abc';
            //             arr.push(this[i]);  
            //         }
            //     }
            //     return arr.sort(
            //         function (a,b) {
            //             return a-b;
            //     });
            // }


                // var str = 'abc';
                // //包装类  在调用原始值是 会自动生成一个 new string().length的方法，然后把它
                // // 赋给 str.length
                // //new String('abc').length
                // console.log(str.length);


                // var num = 123;
                // num.abc = 'abc';
                // //new Number(num).abc = 'abc';  --> delete
                // // 原始值 穿件一个方法不会报错，系统会自动创建一个 new number 但同时就销毁了
                // //就是为了不让他 报错


                // //new Number(num).abc
                // //当在调用 num.abc时也不会报错，因为系统会在创建一个 new number 为你调用时不报错
                // // 这两个  num.abc 不相等， 都是创建出来同时就销毁了
                // console.log(num.abc);


                //javascript模式，0-35页上半部，到50页 上半部分，35-38不用看


                // try...catch 主要是防错

                // try{
                //     console.log('a');
                //     console.log(b);          //如果遇到出错，不会往下执行try里的语句
                //     console.log('c');
                // }catch(e){
                //     console.log(e.name + " : " + e.message);
                // }

                // console.log('b');

                
                    //es5.0严格模式 执行语句  "use strict"
                // 不在兼容es3.0的一些不规则语法，全面使用es的新规范
                    //全局识别       局部识别 





 // <div></div>
    //     var div = document.getElementsByTagName('div')[0];
    //     div.style.width = "100px";
    //     div.style.height = "100px";
    //     div.style.backgroundColor = "red";

    // // 遇到 反复的两个事件来回颠倒 可以使用 累加器， 2种变化 %2，3种变化%3
    //     var count = 0;
    //     div.onclick = function () {
    //         count ++;
    //        if(count % 3 == 1) {
    //            this.style.backgroundColor = "yellow";
    //            this.style.borderRadius = "50%";
    //        }else if(count % 3 == 2){
    //            this.style.backgroundColor = "red";
    //        }else{
    //            this.style.backgroundColor = "blue";
    //        }
    //     }

    


      </script>             


                 <!-- DOM操作 选项卡

        <style>
            .xuanka{
               background-color:papayawhip; 
            }
            .content{
                display: none;
                width: 300px;
                height: 100px;
                border:orange 2px solid; 
                background-color:pink;
            }
            .active{
           background-color: yellow;
                height: 30px;
                width: 100px;
                border-radius:10%;
                border: moccasin solid 2px;
                font-size: 16px;
                font-weight: bold;
            }
            .anniu{
                height: 30px;
                width: 100px;
                background-color: deeppink;
                border-radius:10%;
                border: moccasin solid 2px;
                margin-bottom:5px;
                font-size: 16px;
                
            }
        </style>
        <div class="xuanka">
        <button class="active">科目一</button>
        <button class="anniu">科目二</button>
        <button class="anniu">科目三</button>
        <div class="content" style="display: block">答题</div>
        <div class="content">倒车入库，侧方停车，直角弯，S弯，半坡起步</div>
        <div class="content">公路考</div>
</div>
    <script>       
        var btn = document.getElementsByTagName("button");
        var div = document.getElementsByClassName("content");
        for(var i = 0; i < btn.length; i ++) {
            (function (n) {
                btn[n].onclick = function () {
                    for(var j = 0; j < btn.length; j ++) {
                        btn[j].className = "anniu";
                        div[j].style.display = "none";
                    }
                    this.className = "active";
                    div[n].style.display = "block";
                    }
            }(i))
        }
    



    
    </script> -->

       

        <!-- <script>
            //  小方块运动

                // var div = document.createElement('div'); //创建一个DIV

                // document.body.appendChild(div);// 在body里添加一个DIV
            
                // div.style.width = "100px";
                // div.style.height = "100px";
                // div.style.backgroundColor = "red";
                // div.style.position = "absolute";
                // div.style.left = "0";
                // div.style.top = "0";

                // var count = 1;
                // //setInterval 设置定时器
                // var timer = setInterval(function (){
                //    count += count/7; // 加速度设置
                //    div.style.left = parseInt(div.style.left) + count + "px"; 
                //    div.style.top = parseInt(div.style.top) + count + "px"; 
                //    // 到一定量停止
                //    if(parseInt(div.style.left) > 500 && parseInt(div.style.top) > 500) {
                //        clearInterval(timer); // 删除定时器 达到停止的效果
                //    }
                
                //  },30);
        
        
                
                
 
        
        
        
        
        </script> -->




<!--     *******DOM 查看操作
        不兼容说的是 IE9以及 ie9以下 的版本，ie9以上都兼容了

        遍历节点树：

        parentNode -> 父节点（最顶端的parentNode为 #document)

        childNodes -> 子节点们

        firstChild -> 第一个子节点

        lastChild  -> 最后一个子节点
        
        nextSibling -> 后一个兄弟节点

        previousSibling -> 前一个兄弟节点 
    

        基于元素节点树的遍历：

        parentElement -> 返回当前元素的父元素节点 （IE不兼容）

        children -> 只返回当前元素的元素子节点  ********** 常用

        node.childElementCount === node.children.length

        firstElementChild  -> 返回的是第一个元素节点 （IE不兼容）

        lastElementChild  -> 返回的是最后一个元素节点  （ie不兼容）

        当前元素节点的子元素


        
        *************** 重点 
        元素节点  -  1

        属性节点  -  2

        文本节点  -  3

        注释节点  -  8

        document -  9

        documentFragment  11

        获取节点类型   nodeType
   




        DOM结构树 

        document -> HTMLDcument.prototype -> Dcument.prototype  原型链

         -->
    
    
    <!-- 封装函数，返回元素e的第n层祖先元素节点
    
    
         <div>
             <strong>
                 <span>
                     <i></i>
                 </span>
             </strong>             
         </div>
         <script>          
                function retParent(elem,n) {
                    while(elem && n) {
                        elem = elem.parentElement;
                        n --;
                    }
                    return elem;
                }
        var i = document.getElementsByTagName('i')[0];
         </script> -->

<!-- 

        编辑函数，封装myChildren功能，解决以前部分浏览区的兼容性问题


        <script>        
            Element.prototype.myChildren = function () {
                var child = this.childNodes,
                    len = child.length,
                    arr = [];
                    for(var i = 0; i < len; i ++) {
                        if(child[i].nodeType == 1) {
                            arr.push(child[i]);
                        }
                    }
                return arr;
            }       
        </script>

 -->


        <!-- 封装函数，返回元素e的第n个兄弟元素节点，n为正，返回后面的兄弟元素节点，n为负
            ，返回前面的，n为0，返回自己 -->

     <!-- <div>
        <span></span>
        <p></p>
        <strong></strong>
        <i></i>
        <address></address>
    </div>


          <script>
          
          function retSibling(e,n) {
              while(e && n) {
                  if(n > 0) {
                      if(0 && e.nextElementSibling) {
                          e = e.nextElementSibling;
                      }else{
                          for(e = e.nextSibling; e && e.nodeType != 1; e = e.nextSibling);
                      }                   
                    n --;  
                  }else{
                      if(e.previousElementSibling) {
                          e = e.previousElementSibling;
                      }else{
                          for(e = e.previousSibling; e && e.nodeType != 1; e = e.previousSibling);
                      }
                    n ++;
                  }
              }
              return e;
          }          
     var strong = document.getElementsByTagName('strong')[0];
          
          
          
          </script> -->


          <!-- DOM 基本操作， 增删改插

        增
          document.createElement();     创建元素节点   *******常用
          document.createTextNode();    创建文本节点
          document.createComment();     创建注释节点
          document.createDocumentFragment();   创建文本碎片节点
        
        插
          PARENTNODE.appendChild();     任何一个元素节点都有这个方法，可以理解为 push  ***常用
          PARENTNODE.insertBefore(a,b);  insert A ,Before B ，插入A 在B 之前    **** 常用

        删
          parent.removeChild();     剪切出来  父级剪切出去子元素    ***常用
          child.remove();      销毁，直接  remove();            ****常用

        替换
          parent.replaceChild(new,origin);  拿新的元素 替换老的元素 （原来的被剪切出来）




          Element节点的一些属性

          innerHTML

          innerText(老版本火狐不兼容) / textContent(老版本IE不好使)

          Element节点的一些方法

          ele.setAttribute(a,b);    给一个节点 加上一个 a 的属性， b是名字

          ele.getAttribute(); -->



            <!-- <script>
                var div = document.createElement('div');
                var p = document.createElement('p');
                div.appendChild(p);
                p.innerHTML = "你最帅！";
                div.setAttribute('class','example');
                p.setAttribute('class','slogan');
                document.body.appendChild(div);
                
                
            </script> -->


<!-- 
            <div>
                <i></i>
                <b></b>
                <span></span>
            </div>

            <script>
                // A
                // B
                // C
                    // 插入A 在B 之后
        //思路： 将A 插入到B后，也就相当于，将A插到C前面
        // C后面没有元素 就为null ，当为null 时 直接用 appendChild();方法添加进去
                
                Element.prototype.insertAfter = function (targetNode,afterNode) {

                        var beforeNode = afterNode.nextElementSibling;
                        if(beforeNode == null) {
                            this.appendChild(targetNode);
                        }else{
                            this.insertBefore(targetNode,beforeNode);
                        }
                }
              var div = document.getElementsByTagName('div')[0];
              var i = document.getElementsByTagName('i')[0];
              var b = document.getElementsByTagName('b')[0];
              var span = document.getElementsByTagName('span')[0];
              var p = document.createElement('p');
        </script> -->

 
          <!-- <script>
              判断程序执行所用时间
            var firstTime = new Date().getTime();

            for(var i = 0; i < 100000000; i ++){}
            
            var lastTime = new Date().getTime();

            console.log(lastTime - firstTime);
          </script> -->



<!-- 
   <script>
     // 判断setInterval 准确性
       var firstTIme = new Date().getTime();
    setInterval(function() {

            var lastTime = new Date().getTime();
            console.log(lastTime - firstTIme);
            firstTIme = lastTime;

    },100)
   </script> -->


        <!-- <script>
        // setTimeout 延迟一定时间显示
       setTimeout(function() {
           console.log('a');
       },1000);
          
        </script> -->
<!-- 
        <style>
        input{
            border:1px solid reba(0,0,0,0.8);
            text-align: right;
            font: 20px;
            font-weight: bold;

        }
        
        
        </style>


        minutes:<input type="text" value="0">
        seconds:<input type="text" value="0">

        <script>
            //3分钟计时器
            var minutesNode = document.getElementsByTagName('input')[0];
            var secondsNode = document.getElementsByTagName('input')[1];

            var minutes = 0,
                seconds = 0;

            var timer = setInterval(function() {
                seconds ++;
                if(seconds == 60){
                    seconds = 0;
                    minutes ++;
                }
                minutesNode.value = minutes;
                secondsNode.value = seconds;
                if(minutes == 3){
                    clearInterval(timer);
                }
            },1000)
        
        
        </script> -->

           

    <!-- <script>
        //获取当前页面滚动条数值
    // function getScrolloffset() {
    //     if(window.pageXOffset) {
    //         return {
    //             x : window.pageXOffset,
    //             y : window.pageYOffset
    //         }
    //     }else{
    //         return {
    //             x : document.body.scrollLeft + document.documentElement.scrollLeft,
    //             y : document.body.scrollTop + document.documentElement.scrollTop
    //         }
    //     }
    // }
    
 </script> -->

    



        <!-- <div style="width: 100px; height: 100px; font-size: 30px; line-height: 100px; 
        font-weight: bold; background-color: orange; position: fixed; color: #fff; 
        text-align: center; bottom: 300px; right: 50px; border-radius: 50px; opacity: 0.8;">开始</div>
        <div style="width: 100px; height: 100px; font-size: 30px; line-height: 100px; 
        font-weight: bold; background-color: green; position: fixed; color: #fff; 
        text-align: center; bottom: 150px; right: 50px; border-radius: 50px; opacity: 0.8;">停止</div>
        <script>
         //自动阅读器
        var start = document.getElementsByTagName('div')[0];
        var stop = document.getElementsByTagName('div')[1];
       
        var jishi = 0;
        var key = true;
        
            start.onclick = function() {
                if(key){
                jishi = setInterval(function () {

                    window.scrollBy(0, 100);

                },100);
                key = false;
            }
            };

            stop.onclick = function () {
                clearInterval(jishi);
                key = true;
            };

         
        </script> -->



        <!-- window.getComputedStyle(ele,null)  null是查找伪元素用的 -->
            <!-- 改变伪元素的方法，同时设置几种 class ,改变 class的方法 改变伪元素 -->



        <!-- 结局获取元素的兼容问题 currentStyle是IE产物，getComputedStyle通用的 -->
        <!-- <script>
        function getStyle(elem,prop) {
            if(window.getComputedStyle) {
                return window.getComputedStyle(elem, null)[prop];
            }else{
                return elem.currentStyle[prop];
            }
        }
        
        </script> -->


        <!-- 绑定事件 -->
        <!-- div.onclick = function (){};  一个对象只能绑定一个处理函数
        div.addEventListener('click', function (){},false); 一个对象可以绑定多个***IE9以下不兼容 -->
            <!-- div.attachEvent('onclick', function() {}); IE专用可以绑定多个，执行多个 -->

        

            <!-- <ul>
                <li>a</li>
                <li>a</li>
                <li>a</li>
                <li>a</li>               
            </ul>


            <script>
            
            //  绑定事件 如何用到 循环 会形成闭包，要用立即执行函数
                var li = document.getElementsByTagName('li');    
                function test() {
                    for(var i = 0; i < li.length; i ++) {
                        (function(j){ 
                        li[j].addEventListener('click',function(){
                            console.log(j);
                        },false)}(i))
                        }
                    }
                
                test();
            
            </script> -->

<!-- 
       封装 事件处理函数 ******

    <script>
        function addEvent(elem,type,handle) {

            if(elem.addEventListener) {
                elem.addEventListener(type,handle, false);
            }else if(elem.attachEvent) {
                elem.attachEvent('on' + type, function() {
                    handle.call(elem);
                })
            }else{
                elem['on' + type] = handle;
            }
        } 
    </script>
  -->


             <!-- 解除 事件处理函数 -->

             <!-- ele.onclick = null; -->

             <!-- ele.removeEventListener(type,fn,false) -->



    <!-- 事件处理模型，冒泡，捕获 -->

        <!-- 常规模型 ：冒泡是 结构上自子元素，向父元素冒泡  小到大-->
<!-- 不常规模型 ：捕获是 结构上自父元素，向子元素捕获  大到小-->
    <!-- 如果一个事件同时有这两种方法，那么先捕获后 冒泡 -->

<!-- focus ,blur ,change,submit,reset,select 等事件不冒泡 -->

        <!-- <style>
        .wrapper{
            width: 300px;
            height: 300px;
            background-color: red;
        }
        .content{
            margin-left: 300px;
            width: 200px;
            height: 200px;
            background-color: green;
        }
        .box{
            margin-left: 200px;
            width: 100px;
            height: 100px;
            background-color: orange;
        }
        
        
        </style>
            <div class="wrapper">
                <div class="content">
                    <div class="box"></div>
                </div>
            </div>

        <script type="text/javascript">
        var wrapper = document.getElementsByClassName('wrapper')[0];
        var content = document.getElementsByClassName('content')[0];
        var box = document.getElementsByClassName('box')[0];

        wrapper.addEventListener('click', function () {
            console.log('wrapper')
        }, false);
        content.addEventListener('click', function () {
            console.log('content')
        }, false);
        box.addEventListener('click', function () {
            console.log('box')
        }, false);
        




        </script> -->
  

        <!-- 取消 冒泡事件 -->
        <!-- <style>
        .wrapper{
            background-color: red;
            width: 200px;
            height: 200px;
        }
        </style>
        <div class="wrapper"></div>

        <script>
        
        document.onclick = function () {
            console.log('aaa');
        }
        var div = document.getElementsByClassName('wrapper')[0];

        div.onclick = function(e){
          //  e.stopPropagation(); // 取消冒泡事件方法，在e上 stopPropagation
            e.cancelBubble = true; // IE上的方法； 谷歌也可以用
            this.style.background = "green";
        }
            // 封装 stopBubble方法
            // function stopBubble(event) {
            //     if(event.stopPropagation) {
            //         event.stooPropagation();
            //     }else{
            //         event.cancelBubble = true;
            //     }
            // }
        
        
        
        </script> -->





            <!-- 封装右键点击不出菜单方法 -->

        <!-- <script>
        

        function cancelHandler(event) {
            if(event.preventDefault) {
                event.preventDefault();
            }else{
                event.returnValue = false;
            }
        }
        
        document.oncontextmenu = function (e){
            console.log('a');
            cancelHandler(e);
        }
        
        
        
        </script> -->
<!-- 

        <a href="#">www.baidu.com</a>
        <a href="javascript:void(0)">aaaaa</a>  // 也能取消
        <script>
            //取消 A标签的跳转 事件
        var a = document.getElementsByTagName('a')[0];
        a.onclick = function () {
            return false;
        }
        
        
        </script> -->

        <!-- 事件源对象 -->
        
        <!-- event || window.event 用于IE -->
        <!-- event.target   火狐只有这个         谷歌两个都有
        event.srcElement  IE只有这个 -->

          <!-- <ul>
              <li>1</li>
              <li>2</li>
              <li>3</li>
              <li>4</li>
              <li>5</li>
              <li>6</li>
              <li>7</li>
              <li>8</li>
              <li>9</li>
              <li>10</li>
          </ul>

          <script>
        
          var ul = document.getElementsByTagName('ul')[0];

            ul.onclick = function(e) {
                var event = e || window.event;
                var target = event.target || event.srcElement;
                //   点击的谁，谁就是源对象 点击的li，所以就 获取 li源对象
                console.log(target.innerText);
            }
          
          
          </script> -->

<!-- 
          <div style="width: 100px; height: 100px; background-color: red;
          position: absolute; left: 0; top: 0;"></div>


          <script>
          
           var div = document.getElementsByTagName('div')[0];
            var disX,
                disY;
                div.onmousedown = function (e) {
                    disX = e.pageX - parseInt(div.style.left);
                    disY = e.pageY - parseInt(div.style.top);


                    document.onmousemove = function (e) {
                        var event = e || window.event;             
                        div.style.left = e.pageX - disX + "px";
                        div.style.top = e.pageY - disY + "px";
                    }

                    document.onmouseup = function () {
                        div.onmousemove = null;
                }
                }
          </script> -->




          <!-- 事件分类

        鼠标事件
                        鼠标移动             右键菜单     经过      离开      新经过
        click,mousedown,mousemove,mouseup,contextmenu,mouseover,mouseout,mouseenter,
           新离开
        mouseleave
        click = mousedown + mouseup
    用button来区分鼠标的按键

            document.onmousedown = function (e) {
                if(e.button == 2) {
                    console.log('right')
                }else if(e.botton == 0) {
                    console.log('left')
                }else{
                    console.log('conter')
                }
            }



    DOM3标准规定：click事件只能监听左键，只能通过
mousedown和mouseup来判断鼠标键-->


            <!-- 键盘事件

            keydown,keyup,keypress

            keydown > keypress > keyup

            keydown和keypress的区别

            keydown 可以相应任意键盘按键，keypress只可相应字符类键盘按键

            keypress返回 ASCLL码，可以转换成相应字符 -->


<!-- 
                文本类操作事件

                   获取焦点 失去焦点     文本长度
            input, focus    ,blur,     change -->

<!-- 
            //输入框
        <input type="text" value="请输入用户名" style="color: #999" 
        onfocus="if(this.value=='请输入用户名'){this.value='';this.style.color='#424242'}"
        onblur="if(this.value==''){this.value='请输入用户名',this.style.color='#999'}"> -->

                <!-- 事件分类
            
            窗体操作类（window上的时间)

            滚动条滚动触发      加载完成触发
               scroll            load -->


            
            <!-- json -->

                    <!-- 
                        JSON.parse(); 字符串变成 对象形式
                    JSON.stingify(); 对象形式变成 字符串变成 -->

                        <!-- 异步加载
  
                        1.defer （内外都可以）           2.async （只能加载外部的）
                         IE用的                        非IE用 -->

                        <!-- 解决无论在任何情况下 使用 异步加载 -->
                
                        <!-- <script type="text/javascript">
                        
                      function loadScript(url,callback) {
                        var script = document.createElement('script');
                        script.sytle = 'text/javascript';
                        if(script.readyState){
                            script.onreadystatechange = function () {
                                if(script.readyState == "complete" || script.readyState == "loaded"){
                                    // IE
                                    callback();
                                }
                                }
                            }else{
                                script.onload = function () {
                                    // Safari  chrome firefox opera
                                    callback();
                                }
                            }
                            script.src = "url";
                        document.head.appendChild(script);
                        
                  
                      }
                        

                        //调用  可以写成函数引用的方法
                        loadScript('demo.js', function(){
                            test();
                        });
                        </script> -->


                        <!-- JS的时间线 
                        开始创建 document
                        readyState = loading
                        解析完成
                        readyState = interactive
                            另外一种解析完成方式
            document.addEventListener('DOMcontentLoaded',function () {
                console.log('a')
            },false);

                        加载完成
                        readyState = complete
                        -->
                        

                        <!-- 正则 -->

                        <!-- reg.test()  判断对错
                        str.match() 判断是否有表达式内容 -->

                     <!-- \w == [0-9A-z_]
                     \W == [^\w]
                    \d == [0-9]
                    \D == [^\d] 
                    \s = \r+\n+\f+\v+\t
                        \b == 单词边界-->

















</body>
</html>
    
